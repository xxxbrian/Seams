import re
import string
import jwt
import hashlib
import time
import pickle
import os
from datetime import timezone
import datetime
import secrets
import random
from typing import List, Dict, Union, Optional, Callable

from src.data_store import data_store
from src.config import url, SECRET

from src import backdoor

store = data_store.get()


def pickelsave(func: Callable) -> Callable:

    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        with open('data_store.pickle', 'wb') as f:
            pickle.dump(store, f)
        return result

    return wrapper


def int_now() -> int:
    return int(time.time())


class Seams():

    @staticmethod
    def clear() -> None:
        store['workspace_stats'] = {
            'channels_exist': [{
                'num_channels_exist': 0,
                'time_stamp': int(time.time())
            }],
            'dms_exist': [{
                'num_dms_exist': 0,
                'time_stamp': int(time.time())
            }],
            'messages_exist': [{
                'num_messages_exist': 0,
                'time_stamp': int(time.time())
            }],
        }

    @staticmethod
    def set_workspace_stats(key, offset, time) -> None:
        num_key = f'num_{key}'
        last_num_value = store['workspace_stats'][key][-1][num_key]
        store['workspace_stats'][key].append({
            num_key: last_num_value + offset,
            'time_stamp': time
        })

    @staticmethod
    def analytics_filter(data, key, time) -> List[dict]:
        return [i for i in data[key] if i['time_stamp'] <= time]

    @staticmethod
    def get_workspace_stats() -> dict:
        now = int_now()
        info_dict = {}
        for key in store['workspace_stats'].keys():
            info_dict[key] = Seams.analytics_filter(store['workspace_stats'],
                                                    key, now)
        user_in_cord = 0
        all_users = User.find_all()
        for user in all_users:
            if user.analytics['channels_joined'][-1][
                    'num_channels_joined'] or user.analytics['dms_joined'][-1][
                        'num_dms_joined']:
                user_in_cord += 1
        info_dict['utilization_rate'] = user_in_cord / len(all_users)
        return info_dict


class User():
    '''
    Every user will be store in data_store:[(object) Datastore] as an User object

    Attributes:
        u_id:        (int) user's auth id
        email:       (str) user's email
        password:    (str) user's password
        name_first:  (str) user's first name
        name_last:   (str) user's last name
        handle_str:      (str) generated by user's name

    Example usage:
        # Import
        from src.type import User

        # Instantiate a User object
        new_user = User(email, password, name_first, name_last)

        # Store user to store
        new_user.add_to_store()

        # Find user by u_id
        myuser = User.find_by_id(u_id)
    '''

    def __init__(self, email: str, password: str, name_first: str,
                 name_last: str) -> None:
        self.u_id: int = User.get_last_id() + 1
        self.email: str = email
        self.password: str = User.encrypt(password)
        self.name_first: str = name_first
        self.name_last: str = name_last
        self.handle_str: str = self.generat_handle()
        self.group_id: int = 500 if self.u_id else 0
        self.notification: List[Notification] = []
        self.profile_img: str = f'default-{random.randint(1,1000)}.png'
        time_now = int_now()
        self.analytics: dict = {
            'channels_joined': [{
                'num_channels_joined': 0,
                'time_stamp': time_now
            }],
            'dms_joined': [{
                'num_dms_joined': 0,
                'time_stamp': time_now
            }],
            'messages_sent': [{
                'num_messages_sent': 0,
                'time_stamp': time_now
            }],
        }

    # def __setattr__(self, key, value):
    #     self.__dict__[key] = value

    # COVERAGE
    # def __str__(self) -> str:
    #     info = 'User object:\n'+\
    #         f' - u_id:       {self.u_id}\n' + \
    #         f' - email:      {self.email}\n' + \
    #         f' - password:   {self.password}\n' + \
    #         f' - name:       {self.name_first} {self.name_last}\n' + \
    #         f' - handle:     {self.handle_str}\n' + \
    #         f' - group_id:   {self.group_id}'
    #     return info

    def __hash__(self) -> int:
        return hash(self.u_id)

    def todict(
        self,
        show={
            'u_id', 'email', 'name_first', 'name_last', 'handle_str',
            'profile_img_url'
        }
    ) -> dict:
        info_dict = {
            key: value
            for key, value in self.__dict__.items() if key in show
        }
        if 'profile_img_url' in show:
            info_dict[
                'profile_img_url'] = f'{url}profile_img/{self.profile_img}'
        return info_dict

    @staticmethod
    def find_by_id(u_id: int, only_active=True):
        '''
        Find user by user's u_id

        Args:
            u_id

        Return:
            user
        '''
        res: Optional[User] = None
        for user in store['users']:
            if user.u_id == u_id and (not only_active or user.is_active()):
                res = user
        return res

    @staticmethod
    def find_by_email(email: str, only_active=True):
        '''
        Find user by user's email

        Args:
            email

        Return:
            User
        '''
        res: Optional[User] = None
        for user in store['users']:
            if user.email == email and (not only_active or user.is_active()):
                res = user
        return res

    @staticmethod
    def find_by_handle(handle_str: str, only_active=True):
        '''
        Find user by user's handle_str

        Args:
            handle_str

        Return:
            User
        '''
        res: Optional[User] = None
        for user in store['users']:
            if user.handle_str == handle_str and (not only_active
                                                  or user.is_active()):
                res = user
        return res

    @staticmethod
    def clear() -> None:
        """clear user"""
        store['users'].clear()
        store['login_token'].clear()
        store['reset_code'].clear()

    @staticmethod
    def get_last_id() -> int:
        """return last user id"""
        users: List[User] = list(reversed(store['users']))
        u_id = users[0].u_id if len(users) > 0 else -1
        return u_id

    def add_to_store(self) -> None:
        """add user"""
        store['users'].append(self)

    @staticmethod
    def __generat_20fullname(name_first: str, name_last: str) -> str:
        """generate 20 lowercase full names"""

        fullname = (name_first + name_last).lower()
        fullname = ''.join(list(filter(str.isalnum, fullname)))[:20]
        return fullname

    @staticmethod
    def __generat_fullname_text(fullname) -> str:
        fullname_text = ''
        for i in range(len(fullname)):
            if fullname[i:].isdigit() and int(fullname[i]) != 0:
                break
            fullname_text += fullname[i]
        if len(fullname_text) == len(fullname):
            return fullname.rstrip(string.digits)
        else:
            return fullname_text

    def generat_handle(self) -> str:
        fullname = self.__generat_20fullname(self.name_first, self.name_last)
        fullname_text = self.__generat_fullname_text(fullname)
        fullname_digits = -1
        if len(fullname_text) != len(fullname):
            fullname_digits = int(fullname[len(fullname_text):])

        for user in list(reversed([i for i in store['users']
                                   if i.is_active()])):
            last_text = user.handle_str[:len(fullname_text)]
            last_digit_str = user.handle_str[len(fullname_text):]
            last_digit = int(
                last_digit_str) if last_digit_str.isdigit() else -1
            if fullname_text == last_text and (last_digit_str.isdigit()
                                               or last_digit_str == ''):
                fullname_digits = max(last_digit + 1, fullname_digits)

        if fullname_digits >= 0:
            fullname_text += str(fullname_digits)

        return fullname_text

    def generat_token(self) -> str:
        payload = {
            'u_id': self.u_id,
            'exp': int(time.time() * 1000000),
        }
        token = jwt.encode(payload=payload, key=SECRET, algorithm='HS256')
        store['login_token'].append(token)
        return token

    @staticmethod
    def find_by_token(token):
        res: Optional[User] = None
        if User.token_in_store(token):
            preload = jwt.decode(token, SECRET, algorithms=['HS256'])
            res = User.find_by_id(preload['u_id'])
        return res

    @staticmethod
    def token_in_store(token) -> bool:
        return token in store['login_token']

    @staticmethod
    def remove_token(token) -> None:
        store['login_token'].remove(token)

    @staticmethod
    def find_all():
        res: List[User] = [i for i in store['users'] if i.is_active()]
        return res

    def del_account(self) -> None:
        self.group_id = -1
        self.name_first = 'Removed'
        self.name_last = 'user'
        for msg in store['messages']:
            if msg.u_id == self.u_id:
                msg.content = 'Removed user'

    def is_active(self) -> bool:
        return self.group_id >= 0

    def is_admin(self) -> bool:
        return self.group_id == 0

    @staticmethod
    def check_handle_been_used(handle_str: str) -> bool:
        all_handle = [user.handle_str for user in store['users']]
        return handle_str in all_handle

    @staticmethod
    def check_handle_content_invalid(handle_str: str) -> bool:
        return not handle_str.isalnum()

    @staticmethod
    def check_handle_length_invalid(handle_str: str) -> bool:
        return len(handle_str) < 3 or len(handle_str) > 20

    @staticmethod
    def check_email_invalid(email: str) -> bool:
        """Check whether the email address is valid"""
        regx = r'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$'
        return not re.fullmatch(regx, email)

    @staticmethod
    def check_email_been_used(email: str) -> bool:
        """Check whether the user's email is been used"""
        return User.find_by_email(email) is not None

    @staticmethod
    def check_password_invalid(password: str) -> bool:
        """Check whether the password is satisfy the length request"""
        return len(password) < 6

    @staticmethod
    def check_name_invalid(name: str) -> bool:
        """Check whether the length of user name is satisfy length request"""
        return len(name) < 1 or len(name) > 50

    @staticmethod
    def match_email_password(email: str, password: str):
        """Check whether the input email and password are match"""
        user = User.find_by_email(email)
        return user.password == User.encrypt(password)

    @staticmethod
    def encrypt(password: str) -> str:
        return hashlib.sha256(password.encode()).hexdigest()

    def add_notification(self, notification) -> None:
        self.notification.insert(0, notification)

    def get_notification(self):
        res: List[Notification] = sorted(
            [ntf for ntf in self.notification if ntf.is_available()])
        return res

    def generat_reset_code(self) -> str:
        code = secrets.token_urlsafe()[0:8]
        if code in store['reset_code'].values():
            return self.generat_reset_code()
        else:
            store['reset_code'][self] = code
            backdoor.add_code(code)
            return code

    @staticmethod
    def find_by_reset_code(code):
        user: Optional[User] = None
        for u, c in store['reset_code'].items():
            if c == code:
                user = u
        return user

    def remove_reset_code(self) -> None:
        store['reset_code'].pop(self)

    def password_set(self, pwd: str) -> None:
        self.password = User.encrypt(pwd)
        for token in store['login_token']:
            if self == User.find_by_token(token):
                User.remove_token(token)

    def set_profile_img(self, img_name) -> None:
        self.profile_img = img_name

    def set_analytics(self, key, offset, time) -> None:
        num_key = f'num_{key}'
        last_num_value = self.analytics[key][-1][num_key]
        self.analytics[key].append({
            num_key: last_num_value + offset,
            'time_stamp': time
        })

    # def analytics_filter(data, key, time):
    #     return [i for i in data[key] if i['time_stamp'] < time]

    def get_analytics(self) -> dict:
        now = int_now()
        info_dict = {}
        for key in self.analytics.keys():
            info_dict[key] = Seams.analytics_filter(self.analytics, key, now)

        num_channels_joined = info_dict['channels_joined'][-1][
            'num_channels_joined']
        num_dms_joined = info_dict['dms_joined'][-1]['num_dms_joined']
        num_messages_sent = info_dict['messages_sent'][-1]['num_messages_sent']
        num_channels = len(Channel.get_all())
        num_dms = len(DM.get_all())
        num_messages = len(Message.get_all())
        sum_num = num_channels + num_dms + num_messages
        involvement_rate = (
            (num_channels_joined + num_dms_joined + num_messages_sent) /
            sum_num) if sum_num != 0 else 0
        info_dict[
            'involvement_rate'] = involvement_rate if involvement_rate < 1 else 1
        return info_dict


class Channel():
    '''
    Every channel will be store in data_store:[(object) Datastore] as an Channel object

    Attributes:
        name:         (str)   channel's name
        owners:       (list)  channel's owners
        members:      (list)  channel's members
        channel_id:   (int)   channel's id
        is_public:    (bool)  channel is public or not

    Example usage:
        # Import
        from src.type import Channel

        # Instantiate a Channel object
        new_channel = Channel(u_id, name, is_public)

        # Store channel to store
        new_channel.add_to_store()
    '''

    def __init__(self, u_id: int, name: str, is_public: bool = True) -> None:
        self.name: str = name
        self.owners: List[User] = [User.find_by_id(u_id)]
        self.members: List[User] = [User.find_by_id(u_id)]
        self.channel_id: int = Channel.get_last_id() + 1
        self.is_public: bool = is_public
        self.messages: List[Message] = []
        self.standup: Dict[bool, Optional[User], Optional[Union[int, float]],
                           List[str]] = {
                               'is_active': False,
                               'auth_user': None,
                               'time_finish': None,
                               'message_buffer': [],
                           }

    # def __setattr__(self, key, value):
    #     self.__dict__[key] = value

    # COVERAGE
    # def __str__(self) -> str:
    #     channel_type = 'public' if self.is_public else 'privte'
    #     info = 'Channel object:\n'+\
    #         f' - name:        {self.name}\n'+\
    #         f' - channel_id:  {self.channel_id}\n'+\
    #         f' - type:        {channel_type}\n'+\
    #         f' - members:     {len(self.members)} ({len(self.owners)}owners)'
    #     return info

    def todict(self, show={'channel_id', 'name', 'is_public'}) -> dict:
        info_dict = {
            key: value
            for key, value in self.__dict__.items() if key in show
        }
        if 'owner_members' in show:
            info_dict['owner_members'] = list(user.todict()
                                              for user in self.owners
                                              if user.is_active())
        if 'all_members' in show:
            info_dict['all_members'] = list(user.todict()
                                            for user in self.members
                                            if user.is_active())

        return info_dict

    @staticmethod
    def get_last_id() -> int:
        channel: List[Channel] = list(reversed(store['channels']))
        channel_id = channel[0].channel_id if len(channel) > 0 else -1
        return channel_id

    @staticmethod
    def find_by_id(channel_id: int):
        '''
        Find channel by channel's channel_id

        Args:
            channel_id

        Return:
            Channel
        '''
        res: Optional[User] = None
        for channel in store['channels']:
            if channel.channel_id == channel_id:
                res = channel
        return res

    @staticmethod
    def clear() -> None:
        store['channels'].clear()

    def add_to_store(self) -> None:
        store['channels'].append(self)
        self.owners[0].set_analytics('channels_joined', 1, int_now())
        Seams.set_workspace_stats('channels_exist', 1, int_now())

    def has_user(self, user: User) -> bool:
        return user in self.members

    def addowner(self, user: User) -> None:
        self.owners.append(user)

    def removeowner(self, user: User) -> None:
        self.owners.remove(user)

    def leave(self, user: User) -> None:
        self.members.remove(user)
        user.set_analytics('channels_joined', -1, int_now())

    def join(self, user: User) -> None:
        self.members.append(user)
        user.set_analytics('channels_joined', 1, int_now())

    @staticmethod
    def check_name_invalid(name: str) -> bool:
        """
        Check whether the length of channel name is satisfy length request
        """
        return len(name) < 1 or len(name) > 20

    @staticmethod
    def get_all():
        res: List[Channel] = store['channels']
        return res

    def get_messages(self, start=0, end=-1):
        res: List[Message] = Message.get_messages(self, start, end)
        return res

    def add_message(self, msg) -> None:
        self.messages.insert(0, msg)

    def has_owner(self, user: User) -> bool:
        return user in self.owners or user.is_admin()

    def standup_set(self, auth_user: User, time_finish: Union[int,
                                                              float]) -> bool:
        self.standup['is_active'] = True
        self.standup['auth_user'] = auth_user
        self.standup['time_finish'] = time_finish

    def standup_add(self, sender: User, message: str) -> None:
        self.standup['message_buffer'].append(
            f'{sender.handle_str}: {message}')

    def standup_do(self) -> None:
        self.standup['is_active'] = False
        utc_time = Message.utc_timestamp()
        auth_user = self.standup['auth_user']
        if len(self.standup['message_buffer']) > 0:
            message = '\n'.join(self.standup['message_buffer'])
            new_msg = Message(auth_user.u_id, message, utc_time, self)
            new_msg.add_to_store()
        self.standup['auth_user'] = None
        self.standup['time_finish'] = None
        self.standup['message_buffer'].clear()


class DM():

    def __init__(self, u_id: int, u_ids: list) -> None:
        self.name: str = self.generat_name(u_ids)
        self.owner: User = User.find_by_id(u_id)
        self.members: List[User] = [User.find_by_id(u_id) for u_id in u_ids]
        self.dm_id: int = DM.get_last_id() + 1
        self.messages: List[Message] = []
        self.is_active: bool = True

    # def __setattr__(self, key, value):
    #     self.__dict__[key] = value

    # COVERAGE
    # def __str__(self) -> str:
    #     info = 'DM object:\n'+\
    #         f' - name:        {self.name}\n'+\
    #         f' - DM_id:       {self.dm_id}\n'+\
    #         f' - owner:       id({self.owner.u_id})\n'+\
    #         f' - members:     {len(self.members)}'
    #     return info

    def todict(self, show={'dm_id', 'name'}) -> dict:
        info_dict = {
            key: value
            for key, value in self.__dict__.items() if key in show
        }
        if 'owner' in show:
            info_dict['owner'] = self.owner.todict()
        if 'members' in show:
            info_dict['members'] = list(user.todict() for user in self.members
                                        if user.is_active())

        return info_dict

    @staticmethod
    def get_last_id() -> int:
        dm: List[DM] = list(reversed(store['dms']))
        dm_id = dm[0].dm_id if len(dm) > 0 else -1
        return dm_id

    def generat_name(self, u_ids: List[int]) -> str:
        name_list: List[str] = [
            User.find_by_id(u_id).handle_str for u_id in u_ids
        ]
        name_list.sort()
        return ', '.join(name_list)

    @staticmethod
    def find_by_id(dm_id: int):
        '''
        Find dm by dm's dm_id

        Args:
            dm_id

        Return:
            DM
        '''
        res: Optional[DM] = None
        for dm in store['dms']:
            if dm.dm_id == dm_id and dm.is_active:
                res = dm
        return res

    @staticmethod
    def clear() -> None:
        store['dms'].clear()

    def add_to_store(self) -> None:
        store['dms'].append(self)
        for user in self.members:
            user.set_analytics('dms_joined', 1, int_now())
        Seams.set_workspace_stats('dms_exist', 1, int_now())

    def has_user(self, user: User) -> bool:
        return user in self.members

    def leave(self, user: User) -> None:
        self.members.remove(user)
        user.set_analytics('dms_joined', -1, int_now())

    def get_messages(self, start=0, end=-1) -> list:
        return Message.get_messages(self, start, end)

    @staticmethod
    def get_all() -> list:
        return [dm for dm in store['dms'] if dm.is_active]

    def add_message(self, msg) -> None:
        self.messages.insert(0, msg)

    def has_owner(self, user: User) -> bool:
        return user is self.owner

    def remove(self) -> None:
        self.is_active = False
        for msg in self.messages:
            msg.remove()
        for user in self.members:
            user.set_analytics('dms_joined', -1, int_now())
        Seams.set_workspace_stats('dms_exist', -1, int_now())


class Message():

    def __init__(self, u_id: int, content: str, time_sent: int,
                 sup: Union[Channel, DM]) -> None:
        self.message_id: int = Message.get_last_id() + 1
        self.u_id: int = u_id
        self.sender: User = User.find_by_id(u_id)
        self.content: str = content
        self.time_sent: Union[int, float] = time_sent
        self.is_active: bool = True
        self.sup: Union[Channel, DM] = sup
        self.react_dict: dict = {1: []}
        self.is_pinned: bool = False

    # def __setattr__(self, key, value):
    #     self.__dict__[key] = value

    def __lt__(self, other) -> bool:
        return self.time_sent > other.time_sent

    def todict(self,
               show={
                   'message_id', 'u_id', 'message', 'time_sent', 'reacts',
                   'is_pinned'
               },
               auth_user=None) -> dict:
        info_dict = {
            key: value
            for key, value in self.__dict__.items() if key in show
        }
        if 'time_sent' in show:
            info_dict['time_sent'] = int(info_dict['time_sent'])
        if 'message' in show:
            info_dict['message'] = self.content
        if 'reacts' in show:
            # for id, users in self.react_dict.values():
            #     {'react_id':id,'u_ids':[user.u_id for user in users],'is_this_user_reacted':auth_user in users}
            info_dict['reacts'] = [{
                'react_id': id,
                'u_ids': [user.u_id for user in users],
                'is_this_user_reacted': auth_user in users
            } for id, users in self.react_dict.items()]
        return info_dict

    @staticmethod
    def get_last_id() -> int:
        msg: List[Message] = store['messages']
        message_id = msg[0].message_id if len(msg) > 0 else -1
        return message_id

    @staticmethod
    def find_by_id(message_id):
        '''
        Find message by message's message_id

        Args:
            message

        Return:
            Message
        '''
        res: Message = None
        for msg in store['messages']:
            if msg.message_id == message_id and msg.is_active:
                res = msg
        return res

    @staticmethod
    def clear() -> None:
        store['messages'].clear()

    def add_to_store(self) -> None:
        store['messages'].insert(0, self)
        self.sup.add_message(self)
        user = User.find_by_id(self.u_id)
        user.set_analytics('messages_sent', 1, int(self.time_sent))
        Seams.set_workspace_stats('messages_exist', 1, int(self.time_sent))

    @staticmethod
    def check_length_invalid(msg: str) -> bool:
        return len(msg) < 1 or len(msg) > 1000

    def remove(self) -> None:
        self.is_active = False
        Seams.set_workspace_stats('messages_exist', -1, int_now())

    @staticmethod
    def check_query_str_invalid(query_str: str) -> bool:
        return len(query_str) < 1 or len(query_str) > 1000

    @staticmethod
    def utc_timestamp() -> float:
        dt = datetime.datetime.now(timezone.utc)
        utc_time = dt.replace(tzinfo=timezone.utc)
        return utc_time.timestamp()

    def is_available(self) -> bool:
        return self.is_active and self.time_sent < Message.utc_timestamp()

    @staticmethod
    def get_messages(sup: Union[Channel, DM], start: int, end: int):
        all_message: List[Message] = sorted(
            [msg for msg in sup.messages if msg.is_available()])
        end = len(all_message) if end < 0 else end
        return all_message[start:end]

    @staticmethod
    def get_all():
        res: List[Message] = [
            msg for msg in store['messages'] if msg.is_available()
        ]
        return res

    @staticmethod
    def get_tagged_user(msg: str):
        pattern = re.compile(r'@\w+(?:^[a-z0-9]+$]\w+)*')
        handles = pattern.findall(msg)
        all_user = list(
            set(
                User.find_by_handle(handle.replace('@', ''))
                for handle in handles))
        res: List[User] = [user for user in all_user if not user is None]
        return res


class Notification:

    def __init__(self,
                 sup: Union[Channel, DM],
                 content: str,
                 time_sent=None) -> None:
        self.sup: Union[Channel, DM] = sup
        self.content: str = content
        self.time_sent: Union[int, float] = Message.utc_timestamp(
        ) if time_sent is None else time_sent

    def __lt__(self, other) -> bool:
        return self.time_sent > other.time_sent

    def todict(self,
               show={'channel_id', 'dm_id', 'notification_message'}) -> dict:
        info_dict = {
            key: value
            for key, value in self.__dict__.items() if key in show
        }
        if 'channel_id' in show:
            info_dict['channel_id'] = self.sup.channel_id if type(
                self.sup) is Channel else -1
        if 'dm_id' in show:
            info_dict['dm_id'] = self.sup.dm_id if type(self.sup) is DM else -1
        if 'notification_message' in show:
            info_dict['notification_message'] = self.content
        return info_dict

    def is_available(self) -> bool:
        return self.time_sent < Message.utc_timestamp()


store: Dict[str, Union[List[User], List[Channel], List[DM], List[Message],
                       List[str], dict]]

if os.path.exists('data_store.pickle'):
    with open('data_store.pickle', 'rb') as f:
        store = pickle.load(f)
    print('Reload Cache...')